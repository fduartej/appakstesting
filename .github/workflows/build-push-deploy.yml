name: Build and Deploy Multi-Environment

on:
  push:
    branches:
      - main # Producci√≥n
      - develop # Desarrollo
      - qa # QA
      - uat # UAT
      - helm # Testing Helm
  workflow_dispatch:

env:
  DOTNET_VERSION: "9.0.x"
  IMAGE_NAME: database-test-api

jobs:
  # Job 1: Build una sola vez y genera imagen
  build:
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.vars.outputs.image-tag }}
      short-sha: ${{ steps.vars.outputs.short-sha }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set build variables
        id: vars
        run: |
          echo "image-tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "short-sha=${GITHUB_SHA:0:7}" >> $GITHUB_OUTPUT

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Build application
        run: dotnet build --configuration Release

      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ secrets.AZURE_ACR_SERVER }}
          username: ${{ secrets.AZURE_ACR_USERNAME }}
          password: ${{ secrets.AZURE_ACR_PASSWORD }}

      - name: Build and push Docker image
        run: |
          echo "üê≥ Building image with tag: ${{ steps.vars.outputs.image-tag }}"
          docker build -t ${{ secrets.AZURE_ACR_SERVER }}/${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.image-tag }} .
          docker push ${{ secrets.AZURE_ACR_SERVER }}/${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.image-tag }}

          # Tambi√©n tag como latest para el branch correspondiente
          docker tag ${{ secrets.AZURE_ACR_SERVER }}/${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.image-tag }} ${{ secrets.AZURE_ACR_SERVER }}/${{ env.IMAGE_NAME }}:latest
          docker push ${{ secrets.AZURE_ACR_SERVER }}/${{ env.IMAGE_NAME }}:latest

  # Job 2: Deploy a DEV usando Helm
  deploy-dev:
    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/helm'
    needs: build
    runs-on: ubuntu-latest
    environment: dev
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy with Helm to AKS
        run: |
          echo "üöÄ Deploying to DEV environment with Helm"
          echo "üì¶ Image: ${{ secrets.AZURE_ACR_SERVER }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}"
          echo "üåê Host: ${{ vars.INGRESS_HOST }}"
          echo "üè∑Ô∏è Config Label: ${{ vars.AZURE_APP_CONFIG_LABEL }}"

          # Crear un tarball del chart para enviarlo
          tar -czf chart.tar.gz k8s/chart/

          az aks command invoke \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_AKS_CLUSTER }} \
            --file chart.tar.gz \
            --command "tar -xzf chart.tar.gz && helm upgrade --install ${{ env.IMAGE_NAME }} ./k8s/chart \
              --set image.repository=${{ secrets.AZURE_ACR_SERVER }}/${{ env.IMAGE_NAME }} \
              --set image.tag=${{ needs.build.outputs.image-tag }} \
              --set ingress.host=${{ vars.INGRESS_HOST }} \
              --set environment=${{ vars.APP_ENVIRONMENT }} \
              --set appConfig.endpoint=${{ vars.AZURE_APP_CONFIG_ENDPOINT }} \
              --set appConfig.label=${{ vars.AZURE_APP_CONFIG_LABEL }} \
              --set workloadIdentity.clientId=${{ vars.AZURE_MANAGED_IDENTITY_CLIENT_ID }} \
              --namespace ${{ vars.KUBERNETES_NAMESPACE }} \
              --create-namespace \
              --wait \
              --timeout=10m"

      - name: Verify Helm deployment
        run: |
          echo "‚úÖ Verificando deployment de Helm en DEV..."

          az aks command invoke \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_AKS_CLUSTER }} \
            --command "helm status ${{ env.IMAGE_NAME }} -n ${{ vars.KUBERNETES_NAMESPACE }}"

          echo "üìä Estado de pods:"
          az aks command invoke \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_AKS_CLUSTER }} \
            --command "kubectl get pods -l app=${{ env.IMAGE_NAME }} -n ${{ vars.KUBERNETES_NAMESPACE }} -o wide"

  # Job 3: Deploy a QA usando kubectl manifests
  deploy-qa:
    if: github.ref == 'refs/heads/qa'
    needs: build
    runs-on: ubuntu-latest
    environment: qa
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy to QA environment
        run: |
          echo "üöÄ Deploying to QA environment with kubectl"
          echo "üì¶ Image: ${{ secrets.AZURE_ACR_SERVER }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}"
          echo "üåê Host: ${{ vars.INGRESS_HOST }}"
          echo "üìÅ Namespace: ${{ vars.KUBERNETES_NAMESPACE }}"

          # Aplicar manifests con valores espec√≠ficos de QA
          sed -i "s|{{IMAGE_TAG}}|${{ needs.build.outputs.image-tag }}|g" k8s/deployment.yaml
          sed -i "s|{{INGRESS_HOST}}|${{ vars.INGRESS_HOST }}|g" k8s/ingress.yaml
          sed -i "s|{{ENVIRONMENT}}|${{ vars.APP_ENVIRONMENT }}|g" k8s/deployment.yaml
          sed -i "s|{{AZURE_APP_CONFIG_ENDPOINT}}|${{ vars.AZURE_APP_CONFIG_ENDPOINT }}|g" k8s/deployment.yaml
          sed -i "s|{{AZURE_APP_CONFIG_LABEL}}|${{ vars.AZURE_APP_CONFIG_LABEL }}|g" k8s/deployment.yaml
          sed -i "s|{{AZURE_MANAGED_IDENTITY_CLIENT_ID}}|${{ vars.AZURE_MANAGED_IDENTITY_CLIENT_ID }}|g" k8s/serviceaccount.yaml
          sed -i "s|{{NAMESPACE}}|${{ vars.KUBERNETES_NAMESPACE }}|g" k8s/*.yaml

          az aks command invoke \
            --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} \
            --name ${{ vars.AZURE_AKS_CLUSTER }} \
            --file k8s/ \
            --command "kubectl apply -f . -n ${{ vars.KUBERNETES_NAMESPACE }}"

  # Job 4: Deploy a UAT usando kubectl manifests
  deploy-uat:
    if: github.ref == 'refs/heads/uat'
    needs: build
    runs-on: ubuntu-latest
    environment: uat
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy to UAT environment
        run: |
          echo "üöÄ Deploying to UAT environment with kubectl"
          echo "üì¶ Image: ${{ secrets.AZURE_ACR_SERVER }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}"
          echo "üåê Host: ${{ vars.INGRESS_HOST }}"
          echo "üìÅ Namespace: ${{ vars.KUBERNETES_NAMESPACE }}"

          # Aplicar manifests con valores espec√≠ficos de UAT
          sed -i "s|{{IMAGE_TAG}}|${{ needs.build.outputs.image-tag }}|g" k8s/deployment.yaml
          sed -i "s|{{INGRESS_HOST}}|${{ vars.INGRESS_HOST }}|g" k8s/ingress.yaml
          sed -i "s|{{ENVIRONMENT}}|${{ vars.APP_ENVIRONMENT }}|g" k8s/deployment.yaml
          sed -i "s|{{AZURE_APP_CONFIG_ENDPOINT}}|${{ vars.AZURE_APP_CONFIG_ENDPOINT }}|g" k8s/deployment.yaml
          sed -i "s|{{AZURE_APP_CONFIG_LABEL}}|${{ vars.AZURE_APP_CONFIG_LABEL }}|g" k8s/deployment.yaml
          sed -i "s|{{AZURE_MANAGED_IDENTITY_CLIENT_ID}}|${{ vars.AZURE_MANAGED_IDENTITY_CLIENT_ID }}|g" k8s/serviceaccount.yaml
          sed -i "s|{{NAMESPACE}}|${{ vars.KUBERNETES_NAMESPACE }}|g" k8s/*.yaml

          az aks command invoke \
            --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} \
            --name ${{ vars.AZURE_AKS_CLUSTER }} \
            --file k8s/ \
            --command "kubectl apply -f . -n ${{ vars.KUBERNETES_NAMESPACE }}"

  # Job 5: Deploy a PROD usando kubectl manifests
  deploy-prod:
    if: github.ref == 'refs/heads/main'
    needs: build
    runs-on: ubuntu-latest
    environment: prod
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy to PROD environment
        run: |
          echo "üöÄ Deploying to PROD environment with kubectl"
          echo "üì¶ Image: ${{ secrets.AZURE_ACR_SERVER }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}"
          echo "üåê Host: ${{ vars.INGRESS_HOST }}"
          echo "üìÅ Namespace: ${{ vars.KUBERNETES_NAMESPACE }}"

          # Aplicar manifests con valores espec√≠ficos de PROD
          sed -i "s|{{IMAGE_TAG}}|${{ needs.build.outputs.image-tag }}|g" k8s/deployment.yaml
          sed -i "s|{{INGRESS_HOST}}|${{ vars.INGRESS_HOST }}|g" k8s/ingress.yaml
          sed -i "s|{{ENVIRONMENT}}|${{ vars.APP_ENVIRONMENT }}|g" k8s/deployment.yaml
          sed -i "s|{{AZURE_APP_CONFIG_ENDPOINT}}|${{ vars.AZURE_APP_CONFIG_ENDPOINT }}|g" k8s/deployment.yaml
          sed -i "s|{{AZURE_APP_CONFIG_LABEL}}|${{ vars.AZURE_APP_CONFIG_LABEL }}|g" k8s/deployment.yaml
          sed -i "s|{{AZURE_MANAGED_IDENTITY_CLIENT_ID}}|${{ vars.AZURE_MANAGED_IDENTITY_CLIENT_ID }}|g" k8s/serviceaccount.yaml
          sed -i "s|{{NAMESPACE}}|${{ vars.KUBERNETES_NAMESPACE }}|g" k8s/*.yaml

          az aks command invoke \
            --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} \
            --name ${{ vars.AZURE_AKS_CLUSTER }} \
            --file k8s/ \
            --command "kubectl apply -f . -n ${{ vars.KUBERNETES_NAMESPACE }}"

          echo "‚úÖ Production deployment completed successfully!"
